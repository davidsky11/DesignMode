代理模式：
    为其他对象提供代理以控制对该对象的访问。

JDK动态代理：
    代理类程序运行前并不存在，需要在程序运行时动态生成（无需手工编写代理类源码，根据Java的反射机制动态生成）。

流程：
    1、创建委托类对象，将其以构造函数传入代理处理器，代理处理器ProxyHandler中会以Java反射方式调用该委托类对应的方法；
    2、使用Java反射机制中的Proxy.newProxyInstance方式创建一个代理类实例，创建该实例需要指定该历史的类加载器，需要实现的接口（即目标接口），以及处理代理实例接口调用的处理器；
    3、调用代理类目标接口方法时，会自动将其转发到代理处理器中的invoke方法内，invoke方法内部实现预处理，对委托类方法调用，事后处理等逻辑。

优点：
    1、减少编程的工作量：假如需要实现多种代理处理逻辑，只要写多个代理处理器就可以了，无需每种方式都写一个代理类。
    2、系统扩展性和维护性增强，程序修改起来也方便多了（一般只要修改代理处理器类就行了）。

缺点：
    代理类和委托类需要都实现同一个接口，也就是只有实现了某个接口的类可以使用Java动态代理机制。但是，事实上使用中并不是遇到的所有类都会给你实现一个接口，JDK动态代理显然就不能凑效，这时候就需要用到CGLib动态代理了。

适用场景：
    远程代理，安全代理